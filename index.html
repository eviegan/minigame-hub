<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Game Hub ðŸŽ®</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#090a16; color:#eef4ff; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #hud { position:fixed; right:12px; bottom:12px; background:#0008; backdrop-filter: blur(8px); padding:8px 12px; border-radius:12px; z-index:5 }
    #hud button { border:0; border-radius:12px; padding:8px 12px; font-weight:700; cursor:pointer }
    #menu { position:fixed; inset:0; display:grid; place-items:center; background:linear-gradient(180deg,#0a0718 0%, #090a16 100%); z-index:4 }
    #menu .card { text-align:center; }
    #menu h1 { margin:0 0 6px; font-size:32px }
    #menu p { margin:0 0 18px; color:#a9b7d8 }
    #menu .grid { display:grid; gap:12px; }
    #menu .grid button { font-size:18px; padding:10px 16px; border-radius:14px; border:0; cursor:pointer; background:#8a5dff; color:#0a0718; font-weight:700 }
    canvas { display:block; width:100%; height:100%; }
  </style>
  <!-- Phaser CDN -->
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
</head>
<body>
  <!-- In-game claim button (demo toast) -->
  <div id="hud"><button id="claim">Claim reward</button></div>

  <!-- Game menu overlay -->
  <div id="menu">
    <div class="card">
      <h1>Mini Game Hub ðŸŽ®</h1>
      <p>Pick a game. ESC returns here.</p>
      <div class="grid">
        <button data-mode="dodge">ðŸš— Dodge</button>
        <button data-mode="catch">ðŸ¥¤ Catch</button>
        <button data-mode="clicker">ðŸ‘† Clicker</button>
      </div>
    </div>
  </div>

  <script>
  // --------- Shared helpers ----------
  const W = () => window.innerWidth;
  const H = () => window.innerHeight;

  function toast(scene, msg) {
    const t = scene.add.text(scene.scale.width/2, scene.scale.height*0.85, msg, {
      fontSize:'22px', color:'#fff', backgroundColor:'#0008', padding:{x:12,y:8}
    }).setOrigin(0.5);
    scene.tweens.add({ targets:t, alpha:0, duration:1200, delay:800, onComplete:()=>t.destroy() });
  }

  // --------- Dodge (avoid obstacles) ----------
  class DodgeScene extends Phaser.Scene {
    constructor(){ super('dodge'); this.score=0; this.timeLeft=30; this.speed=180; }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#0a0718');
      this.add.text(width/2, 30, 'ðŸš— Dodge', { fontSize:'24px', color:'#fff' }).setOrigin(0.5);
      this.scoreText = this.add.text(20, 20, 'Score: 0', { fontSize:'20px', color:'#8EFF98' });
      this.timerText = this.add.text(width-20, 20, this.timeLeft+'s', { fontSize:'20px', color:'#ffd86a' }).setOrigin(1,0);

      // Player
      this.player = this.add.rectangle(width/2, height-40, 50, 20, 0xffd86a).setStrokeStyle(2,0xffffff);
      this.physics.add.existing(this.player);
      this.player.body.setCollideWorldBounds(true);

      // Controls
      this.cursors = this.input.keyboard.createCursorKeys();
      this.input.on('pointermove', p => { this.player.x = Phaser.Math.Clamp(p.x, 25, width-25); });

      // Obstacles
      this.obstacles = this.physics.add.group();
      this.time.addEvent({ delay: 600, loop: true, callback: () => {
        const x = Phaser.Math.Between(20, width-20);
        const s = this.add.rectangle(x, -20, Phaser.Math.Between(20, 60), 14, 0x8a5dff);
        this.physics.add.existing(s);
        s.body.setVelocity(0, Phaser.Math.Between(140, 240));
        this.obstacles.add(s);
      }});

      // Collisions
      this.physics.add.overlap(this.player, this.obstacles, () => this.gameOver(), null, this);

      // Timer + scoring
      this.time.addEvent({ delay: 1000, loop:true, callback: () => {
        this.timeLeft--; this.timerText.setText(this.timeLeft+'s');
        this.score += 1; this.scoreText.setText('Score: '+this.score);
        if(this.timeLeft<=0) this.gameOver(true);
      }});

      this.input.keyboard.on('keydown-ESC', () => this.returnToMenu());
    }
    update(){
      // Keyboard move
      if(this.cursors.left.isDown) this.player.body.setVelocityX(-this.speed);
      else if(this.cursors.right.isDown) this.player.body.setVelocityX(this.speed);
      else this.player.body.setVelocityX(0);
    }
    gameOver(timeUp=false){
      this.scene.pause();
      const { width, height } = this.scale;
      const box = this.add.rectangle(width/2, height/2, width*0.8, 170, 0x000000, 0.7);
      const msg = (timeUp ? 'Time! ' : 'Crashed! ') + `Score: ${this.score}\nClick to return`;
      const txt = this.add.text(width/2, height/2, msg, { fontSize:'22px', color:'#fff', align:'center' }).setOrigin(0.5);
      [box, txt].forEach(el => el.setInteractive({ useHandCursor:true }).on('pointerdown', ()=> this.returnToMenu()));
    }
    returnToMenu(){ this.scene.stop(); showMenu(); }
  }

  // --------- Catch (catch coins) ----------
  class CatchScene extends Phaser.Scene {
    constructor(){ super('catch'); this.score=0; this.timeLeft=30; }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#0a0718');
      this.add.text(width/2, 30, 'ðŸ¥¤ Catch', { fontSize:'24px', color:'#fff' }).setOrigin(0.5);
      this.scoreText = this.add.text(20, 20, 'Score: 0', { fontSize:'20px', color:'#8EFF98' });
      this.timerText = this.add.text(width-20, 20, this.timeLeft+'s', { fontSize:'20px', color:'#ffd86a' }).setOrigin(1,0);

      this.physics.world.setBounds(0,0,width,height);

      // Basket
      this.basket = this.add.rectangle(width/2, height-40, 100, 18, 0xffd86a).setStrokeStyle(2,0xffffff);
      this.physics.add.existing(this.basket, true);

      // Coins
      this.coins = this.physics.add.group();
      this.physics.add.overlap(this.basket, this.coins, (_, coin)=> { this.score++; this.scoreText.setText('Score: '+this.score); coin.destroy(); });

      this.time.addEvent({ delay: 650, loop:true, callback: () => {
        const x = Phaser.Math.Between(20, width-20);
        const c = this.add.circle(x, -20, 10, 0x8a5dff);
        this.physics.add.existing(c);
        c.body.setVelocity(0, Phaser.Math.Between(140, 230));
        c.body.setCircle(10);
        this.coins.add(c);
      }});

      // Pointer control
      this.input.on('pointermove', p=> {
        this.basket.x = Phaser.Math.Clamp(p.x, 50, width-50);
        this.basket.body.updateFromGameObject();
      });

      // Timer
      this.time.addEvent({ delay: 1000, loop:true, callback: () => {
        this.timeLeft--; this.timerText.setText(this.timeLeft+'s');
        if(this.timeLeft<=0) this.endGame();
      }});

      this.input.keyboard.on('keydown-ESC', () => this.returnToMenu());
    }
    endGame(){
      this.scene.pause();
      const { width, height } = this.scale;
      const box = this.add.rectangle(width/2, height/2, width*0.8, 170, 0x000000, 0.7);
      const txt = this.add.text(width/2, height/2, `Time!\nScore: ${this.score}\nClick to return`, { fontSize:'22px', color:'#fff', align:'center' }).setOrigin(0.5);
      [box, txt].forEach(el => el.setInteractive({ useHandCursor:true }).on('pointerdown', ()=> this.returnToMenu()));
    }
    returnToMenu(){ this.scene.stop(); showMenu(); }
  }

  // --------- Clicker (tap targets) ----------
  class ClickerScene extends Phaser.Scene {
    constructor(){ super('clicker'); this.score=0; this.timeLeft=20; }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#0a0718');
      this.add.text(width/2, 30, 'ðŸ‘† Clicker', { fontSize:'24px', color:'#fff' }).setOrigin(0.5);
      this.scoreText = this.add.text(20, 20, 'Score: 0', { fontSize:'20px', color:'#8EFF98' });
      this.timerText = this.add.text(width-20, 20, this.timeLeft+'s', { fontSize:'20px', color:'#ffd86a' }).setOrigin(1,0);

      // Target spawner
      const spawn = () => {
        const r = Phaser.Math.Between(18, 36);
        const x = Phaser.Math.Between(r+10, width-r-10);
        const y = Phaser.Math.Between(80, height-r-10);
        const t = this.add.circle(x, y, r, 0x56d0ff).setInteractive({ useHandCursor:true });
        t.on('pointerdown', () => {
          this.score++; this.scoreText.setText('Score: '+this.score);
          this.tweens.add({ targets:t, scale:0, duration:140, onComplete:()=> t.destroy() });
          toast(this, '+1');
        });
        // remove after 1.5s if not clicked
        this.time.delayedCall(1500, ()=> t.destroy());
      };
      this.time.addEvent({ delay: 500, loop:true, callback: spawn });

      // Timer
      this.time.addEvent({ delay: 1000, loop:true, callback: () => {
        this.timeLeft--; this.timerText.setText(this.timeLeft+'s');
        if(this.timeLeft<=0) this.endGame();
      }});

      this.input.keyboard.on('keydown-ESC', () => this.returnToMenu());
    }
    endGame(){
      this.scene.pause();
      const { width, height } = this.scale;
      const box = this.add.rectangle(width/2, height/2, width*0.8, 170, 0x000000, 0.7);
      const txt = this.add.text(width/2, height/2, `Time!\nScore: ${this.score}\nClick to return`, { fontSize:'22px', color:'#fff', align:'center' }).setOrigin(0.5);
      [box, txt].forEach(el => el.setInteractive({ useHandCursor:true }).on('pointerdown', ()=> this.returnToMenu()));
    }
    returnToMenu(){ this.scene.stop(); showMenu(); }
  }

  // --------- Boot Phaser + Menu handling ----------
  const game = new Phaser.Game({
    type: Phaser.AUTO,
    backgroundColor: '#090a16',
    parent: document.body,
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH, width: W(), height: H() },
    physics: { default: 'arcade', arcade: { debug:false } },
    scene: [DodgeScene, CatchScene, ClickerScene]
  });

  function start(mode){
    hideMenu();
    game.scene.start(mode);
  }

  // Menu buttons
  document.querySelectorAll('#menu [data-mode]').forEach(btn=>{
    btn.addEventListener('click', () => start(btn.dataset.mode));
  });

  function showMenu(){ document.getElementById('menu').style.display = 'grid'; }
  function hideMenu(){ document.getElementById('menu').style.display = 'none'; }

  // Claim reward (demo)
  document.getElementById('claim').addEventListener('click', () => {
    const active = game.scene.getScenes(true)[0];
    if(active){ toast(active, 'Reward claimed!'); }
  });

  // Resize handling
  window.addEventListener('resize', () => {
    const s = game.scale;
    s.resize(W(), H());
  });
  </script>
</body>
</html>
