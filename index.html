<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Mini Game Hub üéÆ</title>
  <style>
    :root { color-scheme: dark; }
    html,body { height:100%; margin:0; background:#090a16; color:#eef4ff; font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    canvas { display:block; width:100%; height:100%; }
    #menu, #leaderboardOverlay {
      position:fixed; inset:0; display:none; place-items:center; z-index:5;
      background:linear-gradient(180deg,#0a0718 0%, #090a16 100%);
    }
    #menu .card, #leaderboardOverlay .card {
      width:min(560px, 92%); background:#0f1226; border:1px solid #243; border-radius:16px; padding:20px; box-shadow:0 20px 60px #0007; text-align:center;
    }
    .grid { display:grid; gap:12px; margin-top:14px; }
    .primary { background:#8a5dff; color:#0a0718; font-weight:800; border:0; padding:12px 16px; border-radius:14px; cursor:pointer; font-size:18px }
    .ghost { background:#1b2040; color:#cfe1ff; border:1px solid #2b325d; padding:10px 14px; border-radius:10px; cursor:pointer; font-size:16px }
    #hud { position:fixed; right:12px; bottom:12px; background:#0008; backdrop-filter: blur(8px); padding:8px 12px; border-radius:12px; z-index:4 }
    #hud button { border:0; border-radius:12px; padding:8px 12px; font-weight:700; cursor:pointer }
    table { width:100%; border-collapse:collapse; margin-top:12px; }
    th, td { padding:8px 10px; border-bottom:1px solid #2b325d; text-align:left; }
    .muted { color:#a9b7d8 }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.90.0/dist/phaser.min.js"></script>
</head>
<body>
  <div id="hud"><button id="claim">Claim reward</button></div>

  <div id="menu">
    <div class="card">
      <h1 style="margin:0 0 6px">Mini Game Hub üéÆ</h1>
      <p class="muted" style="margin:0 0 16px">Pick a game. Press <b>ESC</b> to return here.</p>
      <div class="grid">
        <button class="primary" data-mode="dodge">üöó Dodge</button>
        <button class="primary" data-mode="catch">ü•§ Catch</button>
        <button class="primary" data-mode="wheel">üé° Spin (3/day)</button>
        <button class="ghost" id="openLeaderboard">üèÜ Leaderboard</button>
      </div>
    </div>
  </div>

  <div id="leaderboardOverlay">
    <div class="card">
      <h2 style="margin:0 0 6px">üèÜ Leaderboard</h2>
      <p class="muted" style="margin:0 0 10px">Top 5 per game (saved on your device)</p>
      <div id="lbTabs" class="grid" style="grid-template-columns:repeat(4,1fr)">
        <button class="ghost" data-lb="dodge">Dodge</button>
        <button class="ghost" data-lb="catch">Catch</button>
        <button class="ghost" data-lb="wheel">Wheel</button>
        <button class="ghost" data-lb="all">All</button>
      </div>
      <div id="lbTables" style="margin-top:10px; text-align:left"></div>
      <div style="display:flex; gap:8px; justify-content:center; margin-top:14px">
        <button class="ghost" id="clearLB">Clear my scores</button>
        <button class="primary" id="closeLB">Close</button>
      </div>
    </div>
  </div>

  <script>
  const W = () => innerWidth, H = () => innerHeight;
  const SETTINGS = { rewardThreshold: { dodge: 10, catch: 8 }, wheelDailyLimit: 3 };
  const todayKey = () => new Date().toISOString().slice(0,10);

  function toast(scene, msg){
    const t = scene.add.text(scene.scale.width/2, scene.scale.height*0.85, msg, {
      fontSize:'22px', color:'#fff', backgroundColor:'#0008', padding:{x:12,y:8}
    }).setOrigin(0.5);
    scene.tweens.add({ targets:t, alpha:0, duration:1200, delay:800, onComplete:()=>t.destroy() });
  }

  function saveScore(game, value){
    try{
      const key = `lb_${game}`;
      const list = JSON.parse(localStorage.getItem(key) || "[]");
      list.push({ score:value, ts:Date.now() });
      list.sort((a,b)=>b.score-a.score);
      localStorage.setItem(key, JSON.stringify(list.slice(0,5)));
    }catch(e){}
  }
  const getScores = (game) => { try{ return JSON.parse(localStorage.getItem(`lb_${game}`)||"[]"); }catch(e){ return []; } };
  const incSpinCount = () => localStorage.setItem(`wheel_${todayKey()}`, ((+localStorage.getItem(`wheel_${todayKey()}`)||0)+1).toString());
  const getSpinCount = () => +localStorage.getItem(`wheel_${todayKey()}`) || 0;

  function makeRectTexture(scene, key, w, h, fill, stroke=0xffffff){
    if (scene.textures.exists(key)) return;
    const g = scene.add.graphics();
    g.fillStyle(fill, 1).fillRoundedRect(0,0,w,h,6);
    g.lineStyle(2, stroke, 1).strokeRoundedRect(0,0,w,h,6);
    g.generateTexture(key, w, h);
    g.destroy();
  }
  function makeCircleTexture(scene, key, r, fill){
    if (scene.textures.exists(key)) return;
    const g = scene.add.graphics();
    g.fillStyle(fill, 1).fillCircle(r, r, r);
    g.lineStyle(2, 0xffffff, 1).strokeCircle(r, r, r);
    g.generateTexture(key, r*2, r*2);
    g.destroy();
  }

  class DodgeScene extends Phaser.Scene {
    constructor(){ super('dodge'); this.score=0; this.timeLeft=20; this.speed=360; this.rewarded=false; }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#0a0718');
      this.add.text(width/2, 28, 'üöó Dodge', { fontSize:'24px', color:'#fff' }).setOrigin(0.5);
      this.scoreText = this.add.text(20, 16, 'Score: 0', { fontSize:'20px', color:'#8EFF98' });
      this.timerText = this.add.text(width-20, 16, this.timeLeft+'s', { fontSize:'20px', color:'#ffd86a' }).setOrigin(1,0);

      makeRectTexture(this, 'playerRect', 90, 26, 0xffd86a);
      makeRectTexture(this, 'blockRect', 130, 26, 0x8a5dff);

      this.player = this.physics.add.image(width/2, height-60, 'playerRect').setCollideWorldBounds(true);

      this.cursors = this.input.keyboard.createCursorKeys();
      this.input.on('pointermove', p => { this.player.x = Phaser.Math.Clamp(p.x, 45, width-45); });

      this.obstacles = this.physics.add.group({ allowGravity:false });

      this.time.addEvent({ delay: 420, loop: true, callback: () => {
        const x = Phaser.Math.Between(70, width-70);
        const b = this.physics.add.image(x, -20, 'blockRect');
        b.setVelocity(0, Phaser.Math.Between(240, 360));
        this.obstacles.add(b);
        // spawn flash
        const flash = this.add.rectangle(x, 0, 6, 30, 0xffffff).setAlpha(0.7);
        this.tweens.add({ targets: flash, alpha: 0, y: 60, duration: 350, onComplete:()=>flash.destroy() });
      }});

      this.events.on('update', () => this.obstacles.children.iterate(o => { if(o && o.y > height + 50) o.destroy(); }));

      this.physics.add.overlap(this.player, this.obstacles, () => this.gameOver(), null, this);

      this.time.addEvent({ delay: 1000, loop:true, callback: () => {
        this.timeLeft--; this.timerText.setText(this.timeLeft+'s');
        this.score++; this.scoreText.setText('Score: '+this.score);
        if(!this.rewarded && this.score >= SETTINGS.rewardThreshold.dodge){ this.rewarded=true; toast(this,'üéâ Reward unlocked!'); }
        if(this.timeLeft<=0) this.gameOver(true);
      }});

      this.input.keyboard.on('keydown-ESC', () => this.returnToMenu());
    }
    update(){
      if(this.cursors.left.isDown) this.player.setVelocityX(-this.speed);
      else if(this.cursors.right.isDown) this.player.setVelocityX(this.speed);
      else this.player.setVelocityX(0);
    }
    gameOver(timeUp=false){
      this.scene.pause(); saveScore('dodge', this.score);
      const { width, height } = this.scale;
      const msg = (timeUp ? 'Time! ' : 'Crashed! ') + `Score: ${this.score}\nClick to return`;
      const box = this.add.rectangle(width/2, height/2, width*0.84, 170, 0x000000, 0.7);
      const txt = this.add.text(width/2, height/2, msg, { fontSize:'22px', color:'#fff', align:'center' }).setOrigin(0.5);
      [box, txt].forEach(el=>el.setInteractive({useHandCursor:true}).on('pointerdown', ()=> this.returnToMenu()));
    }
    returnToMenu(){ this.scene.stop(); showMenu(); }
  }

  class CatchScene extends Phaser.Scene {
    constructor(){ super('catch'); this.score=0; this.timeLeft=20; this.rewarded=false; }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#0a0718');
      this.add.text(width/2, 28, 'ü•§ Catch', { fontSize:'24px', color:'#fff' }).setOrigin(0.5);
      this.scoreText = this.add.text(20, 16, 'Score: 0', { fontSize:'20px', color:'#8EFF98' });
      this.timerText = this.add.text(width-20, 16, this.timeLeft+'s', { fontSize:'20px', color:'#ffd86a' }).setOrigin(1,0);

      makeRectTexture(this, 'basketRect', 160, 24, 0xffd86a);
      makeCircleTexture(this, 'coinCircle', 18, 0x56d0ff);

      this.basket = this.physics.add.image(width/2, height-60, 'basketRect').setImmovable(true);
      this.basket.body.allowGravity = false;

      this.coins = this.physics.add.group({ allowGravity:false });
      this.physics.add.overlap(this.basket, this.coins, (_, coin)=>{
        this.score++; this.scoreText.setText('Score: '+this.score); coin.destroy();
        if(!this.rewarded && this.score >= SETTINGS.rewardThreshold.catch){ this.rewarded=true; toast(this,'üéâ Reward unlocked!'); }
      });

      this.time.addEvent({ delay: 480, loop:true, callback: ()=>{
        const x = Phaser.Math.Between(30, width-30);
        const coin = this.physics.add.image(x, -20, 'coinCircle');
        coin.setVelocity(0, Phaser.Math.Between(260, 360));
        this.coins.add(coin);
        const flash = this.add.rectangle(x, 0, 6, 30, 0xffffff).setAlpha(0.7);
        this.tweens.add({ targets: flash, alpha: 0, y: 60, duration: 350, onComplete:()=>flash.destroy() });
      }});

      this.events.on('update', () => this.coins.children.iterate(c => { if(c && c.y > height + 50) c.destroy(); }));

      this.input.on('pointermove', p=>{
        this.basket.x = Phaser.Math.Clamp(p.x, 80, width-80);
        this.basket.body.updateFromGameObject();
      });

      this.time.addEvent({ delay:1000, loop:true, callback: ()=>{
        this.timeLeft--; this.timerText.setText(this.timeLeft+'s');
        if(this.timeLeft<=0) this.endGame();
      }});

      this.input.keyboard.on('keydown-ESC', () => this.returnToMenu());
    }
    endGame(){
      this.scene.pause(); saveScore('catch', this.score);
      const { width, height } = this.scale;
      const msg = `Time!\nScore: ${this.score}\nClick to return`;
      const box = this.add.rectangle(width/2, height/2, width*0.84, 170, 0x000000, 0.7);
      const txt = this.add.text(width/2, height/2, msg, { fontSize:'22px', color:'#fff', align:'center' }).setOrigin(0.5);
      [box, txt].forEach(el=>el.setInteractive({useHandCursor:true}).on('pointerdown', ()=> this.returnToMenu()));
    }
    returnToMenu(){ this.scene.stop(); showMenu(); }
  }

  class WheelScene extends Phaser.Scene {
    constructor(){ super('wheel'); this.spinning=false; }
    create(){
      const { width, height } = this.scale;
      this.cameras.main.setBackgroundColor('#0a0718');
      this.add.text(width/2, 28, 'üé° Spin (3/day)', { fontSize:'24px', color:'#fff' }).setOrigin(0.5);
      this.limitText = this.add.text(width/2, 56, '', { fontSize:'16px', color:'#a9b7d8' }).setOrigin(0.5);
      this.updateLimitText();

      const radius = Math.min(width,height)*0.28;
      const prizes = ['+10','+20','+30','+50','Try again','x2','+15','Jackpot'];
      const seg = (Math.PI*2)/prizes.length;

      // Create and register wheel texture
      const g = this.add.graphics({ x: 0, y: 0 });
      for(let i=0;i<prizes.length;i++){
        g.fillStyle(i%2?0x8a5dff:0x56d0ff,1);
        g.slice(radius+5, radius+5, radius, i*seg, (i+1)*seg, false).fillPath();
      }
      g.lineStyle(6,0xffffff).strokeCircle(radius+5, radius+5, radius);
      const wheelKey = 'wheelTex';
      g.generateTexture(wheelKey, radius*2+10, radius*2+10);
      g.destroy();

      this.wheel = this.add.image(width/2, height/2, wheelKey).setInteractive({useHandCursor:true});
      this.wheel.on('pointerdown', ()=> this.trySpin(prizes));

      prizes.forEach((p,i)=>{
        const angle = i*seg + seg/2 - Math.PI/2;
        const x = width/2 + Math.cos(angle)*(radius*0.65);
        const y = height/2 + Math.sin(angle)*(radius*0.65);
        this.add.text(x,y,p,{fontSize:'18px', color:'#0a0718'}).setOrigin(0.5);
      });
      this.add.triangle(width/2, height/2 - radius - 18, 0,18, 18,18, 9,0, 0xffd86a).setStrokeStyle(2,0xffffff);

      this.input.keyboard.on('keydown-ESC', () => this.returnToMenu());
    }
    updateLimitText(){
      const left = Math.max(0, SETTINGS.wheelDailyLimit - getSpinCount());
      this.limitText?.setText(`Spins left today: ${left}/${SETTINGS.wheelDailyLimit}`);
    }
    trySpin(prizes){
      if(this.spinning) return;
      const used = getSpinCount();
      if(used >= SETTINGS.wheelDailyLimit){ toast(this, 'Limit reached. Come back tomorrow!'); return; }
      this.spinning = true;
      const seg = 360/prizes.length;
      const target = Phaser.Math.Between(0, prizes.length-1);
      const angle = 360*4 + (target*seg) + seg/2;
      this.tweens.add({
        targets:this.wheel, angle, duration:3200, ease:'Cubic.easeOut',
        onComplete:()=>{
          this.spinning=false;
          incSpinCount(); this.updateLimitText();
          const prize = prizes[target];
          toast(this, `You got: ${prize}`);
          saveScore('wheel', ['+10','+15','+20','+30','+50','x2','Jackpot'].indexOf(prize)+1);
        }
      });
    }
    returnToMenu(){ this.scene.stop(); showMenu(); }
  }

  const game = new Phaser.Game({
    type: Phaser.AUTO,
    backgroundColor: '#090a16',
    scale: { mode: Phaser.Scale.RESIZE, autoCenter: Phaser.Scale.CENTER_BOTH, width: W(), height: H() },
    physics: { default: 'arcade', arcade: { debug:false } },
    scene: [DodgeScene, CatchScene, WheelScene]
  });

  function start(mode){ hideMenu(); game.scene.start(mode); }

  const menu = document.getElementById('menu');
  function showMenu(){ menu.style.display='grid'; }
  function hideMenu(){ menu.style.display='none'; }
  showMenu();
  document.querySelectorAll('#menu [data-mode]').forEach(btn=>{
    btn.addEventListener('click', () => start(btn.dataset.mode));
  });

  document.getElementById('claim').addEventListener('click', () => {
    const active = game.scene.getScenes(true)[0];
    if(active) toast(active, 'Reward claimed!');
  });

  addEventListener('resize', () => game.scale.resize(W(), H()));

  // Leaderboard overlay
  const lbOverlay = document.getElementById('leaderboardOverlay');
  const lbTables = document.getElementById('lbTables');
  document.getElementById('openLeaderboard').onclick = () => { renderLB('all'); lbOverlay.style.display='grid'; };
  document.getElementById('closeLB').onclick = () => { lbOverlay.style.display='none'; };
  document.getElementById('clearLB').onclick = () => { ['dodge','catch','wheel'].forEach(g=>localStorage.removeItem(`lb_${g}`)); renderLB('all'); };
  document.querySelectorAll('#lbTabs [data-lb]').forEach(b=>{ b.onclick = () => renderLB(b.dataset.lb); });

  function renderLB(which){
    const games = which==='all' ? ['dodge','catch','wheel'] : [which];
    lbTables.innerHTML = games.map(g=>{
      const rows = getScores(g);
      const body = rows.length ? rows.map((r,i)=>`<tr><td>${i+1}</td><td>${r.score}</td><td class="muted">${new Date(r.ts).toLocaleString()}</td></tr>`).join('') : `<tr><td colspan="3" class="muted">No scores yet</td></tr>`;
      return `
        <h3 style="margin:14px 0 6px">${g.toUpperCase()}</h3>
        <table>
          <thead><tr><th>#</th><th>Score</th><th>When</th></tr></thead>
          <tbody>${body}</tbody>
        </table>`;
    }).join('');
  }
  </script>
</body>
</html>
