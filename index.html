<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Mini Game Hub</title>
<style>
  :root { color-scheme: dark; }
  html,body{height:100%;margin:0;background:#090a16;color:#eef4ff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #stage{position:fixed;inset:0}
  canvas{display:block;width:100%;height:100%}

  /* overlays & UI */
  #menu,#leaderboardOverlay,#starter{position:fixed;inset:0;display:none;place-items:center;z-index:6;background:linear-gradient(180deg,#0a0718 0%, #090a16 100%)}
  .card{width:min(560px,92%);background:#0f1226;border:1px solid #243;border-radius:16px;padding:20px;box-shadow:0 20px 60px #0007;text-align:center}
  .grid{display:grid;gap:12px;margin-top:14px}
  .primary{background:#8a5dff;color:#0a0718;font-weight:800;border:0;padding:12px 16px;border-radius:14px;cursor:pointer;font-size:18px}
  .ghost{background:#1b2040;color:#cfe1ff;border:1px solid #2b325d;padding:10px 14px;border-radius:10px;cursor:pointer;font-size:16px}
  .muted{color:#a9b7d8}
  table{width:100%;border-collapse:collapse;margin-top:12px}
  th,td{padding:8px 10px;border-bottom:1px solid #2b325d;text-align:left}

  #hud{position:fixed;right:12px;bottom:12px;background:#0008;backdrop-filter:blur(8px);padding:8px 12px;border-radius:12px;z-index:5}
  #hud button{border:0;border-radius:12px;padding:8px 12px;font-weight:700;cursor:pointer}

  #backGameBtn{position:fixed;left:12px;top:12px;z-index:7;background:#1b2040;color:#cfe1ff;border:1px solid #2b325d;
    padding:8px 12px;border-radius:10px;font-weight:700;cursor:pointer;display:none}

  .chip{position:fixed;left:50%;transform:translateX(-50%);z-index:7;pointer-events:none;
        padding:6px 12px;border-radius:999px;font-weight:800;border:1px solid}
  #combo{top:68px;background:#1b2040;border-color:#2b325d;display:none}
  #mult {top:104px;background:#20351a;border-color:#2b5d33;display:none}

  #errBadge{position:fixed;right:12px;top:12px;background:#4b1010;border:1px solid #7d1b1b;border-radius:10px;padding:8px 12px;display:none;z-index:9}
</style>
</head>
<body>
  <canvas id="stage"></canvas>

  <!-- small HUD -->
  <div id="hud"><button id="claim">Claim reward</button></div>
  <div id="combo" class="chip">Combo √ó2</div>
  <div id="mult"  class="chip">√ó2 active</div>
  <button id="backGameBtn">‚Üê Menu</button>
  <div id="errBadge"></div>

  <!-- Menu -->
  <div id="menu">
    <div class="card">
      <h1 style="margin:0 0 6px">Mini Game Hub</h1>
      <p class="muted" style="margin:0 0 16px">Pick a game. Press <b>ESC</b> or ‚Äú‚Üê Menu‚Äù to return here.</p>
      <div class="grid">
        <button class="primary" data-mode="mole">üéØ Whack-a-Mole</button>
        <button class="primary" data-mode="catch">üß∫ Catch the Coins</button>
        <button class="ghost" id="openLeaderboard">üèÜ Leaderboard</button>
      </div>
    </div>
  </div>

  <!-- Per-game Starter -->
  <div id="starter">
    <div class="card">
      <h2 id="startTitle" style="margin:0 0 8px">Ready?</h2>
      <p class="muted" id="startHint" style="margin:0 0 14px"></p>
      <div class="grid">
        <button class="primary" id="startBtn">Start</button>
        <button class="ghost" id="backBtn">Back</button>
      </div>
      <div id="countdown" style="font-size:56px; margin-top:14px; display:none">3</div>
    </div>
  </div>

  <!-- Leaderboard -->
  <div id="leaderboardOverlay">
    <div class="card">
      <h2 style="margin:0 0 6px">üèÜ Leaderboard</h2>
      <p class="muted" style="margin:0 0 10px">Top 5 per game (saved on your device)</p>
      <div class="grid" id="lbTabs" style="grid-template-columns:repeat(3,1fr)">
        <button class="ghost" data-lb="mole">Mole</button>
        <button class="ghost" data-lb="catch">Catch</button>
        <button class="ghost" data-lb="all">All</button>
      </div>
      <div id="lbTables" style="margin-top:10px;text-align:left"></div>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:14px">
        <button class="ghost" id="clearLB">Clear my scores</button>
        <button class="primary" id="closeLB">Close</button>
      </div>
    </div>
  </div>

<script>
/* ---------------- Error badge (client-side only) ---------------- */
(() => {
  const badge = document.getElementById('errBadge');
  const show = (m) => { badge.textContent = m; badge.style.display = 'block'; };
  addEventListener('error',             e => show(e.message));
  addEventListener('unhandledrejection',e => show(String(e.reason)));
})();

/* ---------------- Tiny sound beeps (no deps) ---------------- */
const Sound = (() => {
  let ctx;
  function ensure(){ if(!ctx) ctx=new (window.AudioContext||window.webkitAudioContext)(); }
  function tone(freq, dur=0.12, type='sine', vol=0.18) {
    ensure(); const o=ctx.createOscillator(), g=ctx.createGain();
    o.type=type; o.frequency.value=freq; o.connect(g); g.connect(ctx.destination);
    const t=ctx.currentTime; g.gain.value=0; g.gain.linearRampToValueAtTime(vol,t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001,t+dur); o.start(t); o.stop(t+dur+0.02);
  }
  function noise(d=0.25,v=0.3){
    ensure(); const n=ctx.sampleRate*d, b=ctx.createBuffer(1,n,ctx.sampleRate), a=b.getChannelData(0);
    for(let i=0;i<n;i++) a[i]=(Math.random()*2-1)*(1-i/n);
    const s=ctx.createBufferSource(); s.buffer=b; const g=ctx.createGain(); g.gain.value=v; s.connect(g); g.connect(ctx.destination); s.start();
  }
  addEventListener('pointerdown', ()=>ensure(), {once:true});
  return { pop:()=>tone(1200,0.08,'triangle',0.16), click:()=>tone(880,0.05,'square',0.1),
           ding:()=>[660,990,1320].forEach((f,i)=>tone(f,0.12-0.02*i,'sine',0.16)),
           boom:()=>{ noise(0.22,0.35); tone(90,0.2,'sine',0.12);} };
})();

/* ---------------- Globals & UI helpers ---------------- */
const stage = document.getElementById('stage');
const W = ()=>stage.width = innerWidth*devicePixelRatio;
const H = ()=>stage.height= innerHeight*devicePixelRatio;
const CTX = ()=>stage.getContext('2d');

const comboChip = document.getElementById('combo');
const multChip  = document.getElementById('mult');
const showCombo=(m)=>{comboChip.textContent=`Combo √ó${m}`;comboChip.style.display='block';};
const hideCombo=()=>{comboChip.style.display='none';};
const showMult =(s)=>{multChip.textContent=`√ó2 active (${s}s)`;multChip.style.display='block';};
const hideMult =()=>{multChip.style.display='none';};

function toast(msg){
  const t=document.createElement('div');
  t.textContent=msg;
  Object.assign(t.style,{position:'fixed',left:'50%',top:'85%',transform:'translateX(-50%)',
    background:'#0008',color:'#fff',padding:'8px 12px',borderRadius:'10px',zIndex:8});
  document.body.appendChild(t);
  setTimeout(()=>{t.style.transition='opacity 1s';t.style.opacity='0';},800);
  setTimeout(()=>t.remove(),1800);
}
function saveScore(game,value){
  try{
    const key=`lb_${game}`;
    const list=JSON.parse(localStorage.getItem(key)||"[]");
    list.push({score:value,ts:Date.now()}); list.sort((a,b)=>b.score-a.score);
    localStorage.setItem(key,JSON.stringify(list.slice(0,5)));
    const bestKey=`best_${game}`; const best=Math.max(value, +(localStorage.getItem(bestKey)||0));
    localStorage.setItem(bestKey,best);
  }catch(e){}
}
const getScores=(g)=>{try{return JSON.parse(localStorage.getItem(`lb_${g}`)||"[]")}catch(e){return[]}};
const getBest  =(g)=>+localStorage.getItem(`best_${g}`)||0;

/* ---------------- Simple engine (no libs) ---------------- */
const Engine = (() => {
  let raf=0, running=false, last=0, update=null, draw=null, cleanup=null, pointer=null;
  function loop(ts){
    if(!running) return;
    const dt=Math.min(0.033,(ts-last)/1000); last=ts;
    update && update(dt);
    CTX().clearRect(0,0,W(),H());
    draw && draw(CTX());
    raf=requestAnimationFrame(loop);
  }
  function start(u,d,c,p){
    stop(); running=true; update=u; draw=d; cleanup=c||null; pointer=p||null; last=performance.now();
    raf=requestAnimationFrame(loop);
    stage.onpointermove = stage.ontouchmove = (e)=>{
      const rect=stage.getBoundingClientRect();
      const x=(e.touches?e.touches[0].clientX:e.clientX)-rect.left;
      const y=(e.touches?e.touches[0].clientY:e.clientY)-rect.top;
      pointer && pointer('move', x*devicePixelRatio, y*devicePixelRatio);
    };
    stage.onpointerdown = (e)=>{
      const rect=stage.getBoundingClientRect(); const x=(e.clientX-rect.left)*devicePixelRatio, y=(e.clientY-rect.top)*devicePixelRatio;
      pointer && pointer('down', x, y);
    };
  }
  function stop(){
    running=false; cancelAnimationFrame(raf);
    stage.onpointermove=stage.onpointerdown=null;
    cleanup && cleanup();
  }
  return { start, stop };
})();

/* ---------------- Whack-a-Mole (canvas) ---------------- */
function playMole(){
  const state={
    timeLeft:25, score:0, grid:[], moles:[], spawnT:0, combo:0, comboTO:null
  };
  const cols=(Math.min(innerWidth,innerHeight)<720)?3:4;
  const rows=cols;
  const gridW=Math.min(W()*0.9,H()*0.78), cell=gridW/cols;
  const sx=W()/2-gridW/2+cell/2, sy=H()*0.2+cell/2;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      state.grid.push({x:sx+c*cell, y:sy+r*cell});
    }
  }
  const animals=['üêπ','üê±','üê∂','üê∞'];

  function bumpCombo(){
    if(state.comboTO){ state.combo=Math.min(state.combo+1,9); } else { state.combo=1; }
    clearTimeout(state.comboTO);
    state.comboTO=setTimeout(()=>{ state.combo=0; hideCombo(); },1500);
    return state.combo>=5?3:state.combo>=3?2:1;
  }
  function endGame(){
    Engine.stop(); clearTimeout(state.comboTO); hideCombo();
    saveScore('mole',state.score);
    toast(`Time! Score: ${state.score}`);
    showMenu();
  }

  function update(dt){
    state.spawnT-=dt;
    if(state.spawnT<=0){
      // spawn a mole/bomb in free hole
      const freeIdx = state.grid.map((_,i)=>i).filter(i=>!state.moles.find(m=>m.idx===i));
      if(freeIdx.length){
        const idx = freeIdx[Math.floor(Math.random()*freeIdx.length)];
        const isBomb = Math.random()<0.18;
        state.moles.push({idx, bomb:isBomb, t:0.78, scale:0.85});
      }
      state.spawnT = 0.62;
    }
    // tick moles
    state.moles.forEach(m=>{ m.t -= dt; m.scale = Math.min(1, m.scale+dt*2); });
    state.moles = state.moles.filter(m=>m.t>0);

    // timer
    state.timeLeft -= dt;
    if(state.timeLeft<=0) endGame();
  }

  function draw(ctx){
    ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle';
    // title & HUD
    ctx.fillStyle='#fff'; ctx.font=`${24*devicePixelRatio}px system-ui, sans-serif`;
    ctx.fillText('üéØ Whack-a-Mole', W()/2, 28*devicePixelRatio);
    ctx.fillStyle='#8EFF98'; ctx.font=`${20*devicePixelRatio}px system-ui,sans-serif`;
    ctx.fillText(String(Math.round(state.score)), 20*devicePixelRatio, 18*devicePixelRatio);
    ctx.fillStyle='#ffd86a'; ctx.textAlign='right';
    ctx.fillText(`${Math.ceil(state.timeLeft)}s`, W()-20*devicePixelRatio, 18*devicePixelRatio);

    // holes
    const plateW=96*devicePixelRatio, plateH=28*devicePixelRatio;
    ctx.strokeStyle='#2b325d'; ctx.lineWidth=2*devicePixelRatio; ctx.fillStyle='#1b2040';
    for(const g of state.grid){
      const x=g.x-plateW/2, y=g.y+20*devicePixelRatio-plateH/2, r=6*devicePixelRatio;
      roundRect(ctx,x,y,plateW,plateH,r,true,true);
    }
    // moles
    for(const m of state.moles){
      const g=state.grid[m.idx]; const s=64*devicePixelRatio*m.scale;
      ctx.font = `${s}px "Apple Color Emoji","Segoe UI Emoji",system-ui`;
      ctx.fillText(m.bomb?'üí£':animals[(m.idx+m.scale*10|0)%animals.length], g.x, g.y);
    }
    ctx.restore();
  }

  function onPointer(type,x,y){
    if(type!=='down') return;
    // find mole under pointer
    for(const m of state.moles){
      const g=state.grid[m.idx]; const r=34*devicePixelRatio;
      if(Math.hypot(x-g.x,y-g.y) < r){
        if(m.bomb){
          Sound.boom(); state.score=Math.max(0,state.score-2); state.combo=0; hideCombo();
        }else{
          const mult=bumpCombo(); Sound.pop(); state.score+=mult; showCombo(mult);
        }
        // remove mole
        state.moles = state.moles.filter(mm=>mm!==m);
        break;
      }
    }
  }

  Engine.start(update, draw, ()=>{ clearTimeout(state.comboTO); }, onPointer);
}

/* ---------------- Catch the Coins (canvas) ---------------- */
function playCatch(){
  const state={
    timeLeft:25, score:0, items:[], spawnT:0.52, basketX:W()/2, mult:1, multLeft:0, combo:0, comboTO:null
  };
  const ground = H()-60*devicePixelRatio;
  function bumpCombo(){
    if(state.comboTO){ state.combo=Math.min(state.combo+1,9); } else { state.combo=1; }
    clearTimeout(state.comboTO);
    state.comboTO=setTimeout(()=>{ state.combo=0; hideCombo(); },1500);
    return state.combo>=5?3:state.combo>=3?2:1;
  }
  function activateMult(s){
    state.mult=2; state.multLeft=s; showMult(state.multLeft);
  }
  function endGame(){
    Engine.stop(); clearTimeout(state.comboTO); hideCombo(); hideMult();
    saveScore('catch',state.score);
    toast(`Time! Score: ${state.score}`);
    showMenu();
  }
  function update(dt){
    // spawn
    state.spawnT-=dt;
    if(state.spawnT<=0){
      const r=Math.random(); let type='coin';
      if(r<0.14) type='bomb'; else if(r>0.84) type='mult';
      state.items.push({x: between(40,W()-40), y:-30*devicePixelRatio, vy: 120*devicePixelRatio, type});
      state.spawnT=0.52;
    }
    // physics
    state.items.forEach(it=>{ it.vy = Math.min(it.vy+750*devicePixelRatio*dt, 1100*devicePixelRatio); it.y += it.vy*dt; });
    state.items = state.items.filter(i=>i.y < H()+60*devicePixelRatio);

    // basket follow (pointer moves set it)
    // collisions
    const bw=180*devicePixelRatio, bh=26*devicePixelRatio, by=ground;
    state.items = state.items.filter(it=>{
      if(it.y>by-bh && it.x>state.basketX-bw/2 && it.x<state.basketX+bw/2){
        if(it.type==='coin'){
          const mult=bumpCombo()*state.mult; Sound.pop(); state.score+=mult; showCombo(mult);
        }else if(it.type==='bomb'){
          Sound.boom(); state.score=Math.max(0,state.score-3); state.combo=0; hideCombo();
        }else if(it.type==='mult'){
          Sound.ding(); activateMult(6);
        }
        return false;
      }
      return true;
    });

    // timer
    state.timeLeft -= dt;
    if(state.timeLeft<=0) endGame();

    // mult countdown
    if(state.mult>1){
      state.multLeft -= dt;
      if(state.multLeft>0){ showMult(Math.ceil(state.multLeft)); }
      else { state.mult=1; hideMult(); }
    }
  }
  function draw(ctx){
    ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillStyle='#fff'; ctx.font=`${24*devicePixelRatio}px system-ui, sans-serif`;
    ctx.fillText('üß∫ Catch the Coins', W()/2, 28*devicePixelRatio);
    ctx.fillStyle='#8EFF98'; ctx.font=`${20*devicePixelRatio}px system-ui,sans-serif`;
    ctx.fillText(String(Math.round(state.score)), 20*devicePixelRatio, 18*devicePixelRatio);
    ctx.fillStyle='#ffd86a'; ctx.textAlign='right';
    ctx.fillText(`${Math.ceil(state.timeLeft)}s`, W()-20*devicePixelRatio, 18*devicePixelRatio);

    // items
    ctx.textAlign='center'; ctx.textBaseline='middle';
    for(const it of state.items){
      const emoji = it.type==='coin'?'ü™ô':it.type==='bomb'?'üß®':'‚ú®';
      ctx.font = `${52*devicePixelRatio}px "Apple Color Emoji","Segoe UI Emoji",system-ui`;
      ctx.fillText(emoji, it.x, it.y);
    }
    // basket
    const bw=180*devicePixelRatio, bh=26*devicePixelRatio;
    ctx.fillStyle='#ffd86a'; ctx.strokeStyle='#fff'; ctx.lineWidth=2*devicePixelRatio;
    roundRect(ctx, state.basketX-bw/2, ground-bh/2, bw, bh, 6*devicePixelRatio, true, true);

    ctx.restore();
  }
  function onPointer(type,x){
    if(type==='move'){ state.basketX = clamp(x, 90*devicePixelRatio, W()-90*devicePixelRatio); }
  }

  Engine.start(update, draw, ()=>{ clearTimeout(state.comboTO); }, onPointer);
}

/* ---------------- UI wiring ---------------- */
const menu           = document.getElementById('menu');
const starter        = document.getElementById('starter');
const backBtn        = document.getElementById('backBtn');
const startBtn       = document.getElementById('startBtn');
const startTitle     = document.getElementById('startTitle');
const startHint      = document.getElementById('startHint');
const cd             = document.getElementById('countdown');
const backGameBtn    = document.getElementById('backGameBtn');
const lbOverlay      = document.getElementById('leaderboardOverlay');
const lbTables       = document.getElementById('lbTables');

function showMenu(){ hideCombo(); hideMult(); menu.style.display='grid'; starter.style.display='none'; backGameBtn.style.display='none'; }
function hideMenu(){ menu.style.display='none'; }
function stopAllScenes(){ Engine.stop(); }

let pendingMode=null;
function openStarter(mode){
  pendingMode=mode;
  startTitle.textContent = mode==='mole' ? 'Whack-a-Mole' : 'Catch the Coins';
  startHint.textContent  = mode==='mole' ? 'Tap animals to score. Avoid bombs!' :
                           'Move basket to catch ü™ô; avoid üß®; grab ‚ú® for √ó2!';
  starter.style.display='grid'; cd.style.display='none';
}
function startScene(mode){
  stopAllScenes();
  backGameBtn.style.display='inline-block';
  if(mode==='mole') playMole(); else playCatch();
}

startBtn.onclick=()=>{ Sound.click(); cd.style.display='block'; let n=3; cd.textContent=n;
  const tick=()=>{ n--; if(n>0){ cd.textContent=n; setTimeout(tick,700); } else { starter.style.display='none'; startScene(pendingMode); } };
  setTimeout(tick,700);
};
backBtn.onclick = ()=>{ Sound.click(); starter.style.display='none'; showMenu(); };
document.querySelectorAll('#menu [data-mode]').forEach(b=>b.addEventListener('click',()=>{ hideMenu(); openStarter(b.dataset.mode); }));
backGameBtn.onclick=()=>{ Sound.click(); stopAllScenes(); showMenu(); };

addEventListener('keydown',e=>{ if(e.key==='Escape'){ stopAllScenes(); showMenu(); }});

/* leaderboard overlay */
document.getElementById('openLeaderboard').onclick=()=>{ renderLB('all'); lbOverlay.style.display='grid'; };
document.getElementById('closeLB').onclick=()=>{ lbOverlay.style.display='none'; };
document.getElementById('clearLB').onclick=()=>{ ['mole','catch'].forEach(g=>{localStorage.removeItem(`lb_${g}`);localStorage.removeItem(`best_${g}`)}); renderLB('all'); };
document.querySelectorAll('#lbTabs [data-lb]').forEach(b=>b.onclick=()=>renderLB(b.dataset.lb));
function renderLB(which){
  const games=which==='all'?['mole','catch']:[which];
  lbTables.innerHTML=games.map(g=>{
    const rows=getScores(g), best=getBest(g);
    const body=rows.length?rows.map((r,i)=>`<tr><td>${i+1}</td><td>${r.score}</td><td class="muted">${new Date(r.ts).toLocaleString()}</td></tr>`).join('')
                          :`<tr><td colspan="3" class="muted">No scores yet</td></tr>`;
    return `<h3 style="margin:14px 0 6px">${g.toUpperCase()} ‚Äî Best: ${best}</h3>
            <table><thead><tr><th>#</th><th>Score</th><th>When</th></tr></thead><tbody>${body}</tbody></table>`;
  }).join('');
}

/* claim button */
document.getElementById('claim').onclick=()=>toast('Reward claimed!');

/* utils */
function between(a,b){ return a*devicePixelRatio + Math.random()*(b*devicePixelRatio - a*devicePixelRatio); }
function clamp(v,min,max){ return Math.max(min,Math.min(max,v)); }
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  if(w<2*r) r=w/2; if(h<2*r) r=h/2;
  ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
  if(fill) ctx.fill(); if(stroke) ctx.stroke();
}

/* boot */
function layout(){ W(); H(); }
window.addEventListener('resize', layout, {passive:true});
layout();
showMenu();
</script>
</body>
</html>
